---
layout: post
title: "Completed applications & the horrors of self inflicted technical debt"
category: tech
---

Lets add AI to everything users will enjoy it they said, its a good idea they said, lets ruin perfectly fine applications they said.


### The humanity of creating software

It is ultimately human to crave change in stable systems, people want innovation and they want it now -- even when the innovation may kill the original identity of their project.
As the pathetic humans that we are, we tend to be annoyed, bored even, by stability and lack of change wherever it may be. Thus a new manmade horror is crafted from the tears of middle management; Self inflicted technical debt.

#### What even is technical debt?
According to a seminar held in in Dagstuhl:

> In software-intensive systems, technical debt is a collection of design or implementation constructs that are expedient in the short term, but set up a technical context that can make future changes more costly or impossible. Technical debt presents an actual or contingent liability whose impact is limited to internal system qualities, primarily maintainability and evolvability.

So in short, make shitty choices now and you've got yourself some lovely technical debt.

Just like normal debt, technical debt can also accumulate interest, as you pile up new code reliant on that one hacky script that you wrote two years ago you might hit it's limitations and have to accumulate more technical debt by creating more, even hackier workarounds. And just like normal debt, Technical debt is horrendous to deal with.

#### Why not just write good code then?

Great question, well you see that's not how debt works; You can have a perfectly fine solution to a problem that becomes technical debt someday, "good code" is defined by the requirements of the projects and the current standards that surround the said project
And when those requirements change due to some hit new feature that middle management suddenly wants (say, I don't know, LLMs for example :D), you're stuck with perfectly fine code that just became technical debt with one Jira ticket.

### Completed/Perfect software exists

How many times have you looked at `ls` and thought maybe this application needs some new features? never? neither did the `coreutils` developers.
The code base for `ls` is a 6000 line file that hasn't received a major change in 32 years. because it's perfect. it doesn't need styling or a talking idiot that uses the word "delve" too much; It is the combined efforts of some nerds that didn't have a middle management to bother them, no Jira ticket was made and no scrum master was hired. Yet they seem to have produced perfect software, how's that possible?

The answer is very straightforward. `ls` is a simple software with clear outlines in mind. It is made for one goal and one goal only. AS ALL SOFTWARE SHOULD BE.
When software has clear goals and outlines in mind, it is easily "completed", as in "Not in need of new features". The development of this completed software will usually amount to bug fixes and compatibility changes.

#### Why not just create straightforward software then?

Simple! middle management wants to keep their jobs :D

Jokes aside; this investor-oriented 
